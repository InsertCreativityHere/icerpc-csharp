// Copyright (c) ZeroC, Inc. All rights reserved.

// <auto-generated/>
// slicec-cs version: '0.1.0'
// Generated from file: 'ExceptionTests.slice'

#nullable enable

#pragma warning disable 1591 // Missing XML Comment
using IceRpc.Slice;

[assembly:IceRpc.Slice.Slice("ExceptionTests.slice")]

namespace IceRpc.Tests.Slice
{
    /// <summary>The client-side interface for Slice interface ExceptionOperations. <seealso cref="IExceptionOperations"/>.</summary>
    [IceRpc.Slice.TypeId("::IceRpc::Tests::Slice::ExceptionOperations")]
    public partial interface IExceptionOperationsPrx
    {
        /// <param name="invocation">The invocation properties.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        global::System.Threading.Tasks.Task<MyExceptionA> OpMyExceptionAAsync(
            MyExceptionA p1,
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default);

        /// <param name="invocation">The invocation properties.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        global::System.Threading.Tasks.Task ThrowAAsync(
            int a,
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default);

        /// <param name="invocation">The invocation properties.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        global::System.Threading.Tasks.Task ThrowAorBAsync(
            int a,
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default);

        /// <param name="invocation">The invocation properties.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        global::System.Threading.Tasks.Task ThrowRemoteExceptionAsync(
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>Typed proxy record struct. It implements <see cref="IExceptionOperationsPrx"/> by sending requests to a remote IceRPC service.</summary>
    [IceRpc.Slice.TypeId("::IceRpc::Tests::Slice::ExceptionOperations")]
    public readonly partial record struct ExceptionOperationsPrx : IExceptionOperationsPrx, IPrx, IceRpc.Slice.IServicePrx
    {
        /// <summary>Converts the arguments of each operation that takes arguments into a request payload.</summary>
        public static class Request
        {
            /// <summary>Creates the request payload for operation opMyExceptionA.</summary>
            /// <param name="encoding">The encoding of the payload.</param>
            /// <returns>The payload encoded with <paramref name="encoding"/>.</returns>
            public static global::System.IO.Pipelines.PipeReader OpMyExceptionA(
                SliceEncoding encoding,
                MyExceptionA p1)
            {
                var pipe_ = new global::System.IO.Pipelines.Pipe();
                var encoder_ = new SliceEncoder(pipe_.Writer, encoding, default);
                Span<byte> sizePlaceholder_ = encoder_.GetPlaceholderSpan(4);
                int startPos_ = encoder_.EncodedByteCount;
                encoder_.EncodeException(p1);
                encoding.EncodeFixedLengthSize(encoder_.EncodedByteCount - startPos_, sizePlaceholder_);

                pipe_.Writer.Complete();  // flush to reader and sets Is[Writer]Completed to true.
                return pipe_.Reader;
            }

            /// <summary>Creates the request payload for operation throwA.</summary>
            /// <param name="encoding">The encoding of the payload.</param>
            /// <returns>The payload encoded with <paramref name="encoding"/>.</returns>
            public static global::System.IO.Pipelines.PipeReader ThrowA(
                SliceEncoding encoding,
                int a)
            {
                var pipe_ = new global::System.IO.Pipelines.Pipe();
                var encoder_ = new SliceEncoder(pipe_.Writer, encoding, default);
                Span<byte> sizePlaceholder_ = encoder_.GetPlaceholderSpan(4);
                int startPos_ = encoder_.EncodedByteCount;
                encoder_.EncodeInt(a);
                encoding.EncodeFixedLengthSize(encoder_.EncodedByteCount - startPos_, sizePlaceholder_);

                pipe_.Writer.Complete();  // flush to reader and sets Is[Writer]Completed to true.
                return pipe_.Reader;
            }

            /// <summary>Creates the request payload for operation throwAorB.</summary>
            /// <param name="encoding">The encoding of the payload.</param>
            /// <returns>The payload encoded with <paramref name="encoding"/>.</returns>
            public static global::System.IO.Pipelines.PipeReader ThrowAorB(
                SliceEncoding encoding,
                int a)
            {
                var pipe_ = new global::System.IO.Pipelines.Pipe();
                var encoder_ = new SliceEncoder(pipe_.Writer, encoding, default);
                Span<byte> sizePlaceholder_ = encoder_.GetPlaceholderSpan(4);
                int startPos_ = encoder_.EncodedByteCount;
                encoder_.EncodeInt(a);
                encoding.EncodeFixedLengthSize(encoder_.EncodedByteCount - startPos_, sizePlaceholder_);

                pipe_.Writer.Complete();  // flush to reader and sets Is[Writer]Completed to true.
                return pipe_.Reader;
            }
        }

        /// <summary>Holds a <see cref="IceRpc.Slice.ResponseDecodeFunc{T}"/> for each non-void remote operation defined in <see cref="IExceptionOperationsPrx"/>.</summary>
        public static class Response
        {
            /// <summary>The <see cref="ResponseDecodeFunc{T}"/> for the return value type of operation opMyExceptionA.</summary>
            public static async global::System.Threading.Tasks.ValueTask<MyExceptionA> OpMyExceptionAAsync(
                IceRpc.IncomingResponse response,
                global::System.Threading.CancellationToken cancel) =>
                await response.ToReturnValueAsync(
                    _defaultActivator,
                    (ref SliceDecoder decoder) => new MyExceptionA(ref decoder),
                    hasStream: false,
                    cancel).ConfigureAwait(false);
        }

        /// <summary>The default path for services that implement Slice interface <c>ExceptionOperations</c>.</summary>
        public static readonly string DefaultPath = typeof(ExceptionOperationsPrx).GetDefaultPath();

        private static readonly IActivator _defaultActivator =
            SliceDecoder.GetActivator(typeof(ExceptionOperationsPrx).Assembly);

        /// <summary>The proxy to the remote service.</summary>
        public IceRpc.Proxy Proxy { get; init; }

        /// <summary>Implicit conversion to <see cref="IceRpc.Slice.ServicePrx"/>.</summary>
        public static implicit operator IceRpc.Slice.ServicePrx(ExceptionOperationsPrx prx) => new(prx.Proxy);

        /// <summary>Creates a new <see cref="ExceptionOperationsPrx"/> from the give connection and path.</summary>
        /// <param name="connection">The connection. If it's an outgoing connection, the endpoint of the new proxy is
        /// <see cref="Connection.RemoteEndpoint"/>; otherwise, the new proxy has no endpoint.</param>
        /// <param name="path">The path of the proxy. If null, the path is set to <see cref="DefaultPath"/>.</param>
        /// <param name="invoker">The invoker. If null and connection is an incoming connection, the invoker is set to
        /// the server's invoker.</param>
        /// <returns>The new proxy.</returns>
        public static ExceptionOperationsPrx FromConnection(
            IceRpc.Connection connection,
            string? path = null,
            IceRpc.IInvoker? invoker = null) =>
            new(IceRpc.Proxy.FromConnection(connection, path ?? DefaultPath, invoker));

        /// <summary>Creates a new relative proxy with the given path.</summary>
        /// <param name="path">The path.</param>
        /// <returns>The new relative proxy.</returns>
        public static ExceptionOperationsPrx FromPath(string path) => new(IceRpc.Proxy.FromPath(path));

        /// <summary>Creates a new <see cref="ExceptionOperationsPrx"/> from a string and invoker.</summary>
        /// <param name="s">The string representation of the proxy.</param>
        /// <param name="invoker">The invoker of the new proxy.</param>
        /// <param name="format">The proxy format to use for this parsing. Use <c>null</c> to select the default URI format.
        /// </param>
        /// <returns>The new proxy.</returns>
        /// <exception cref="global::System.FormatException"><c>s</c> does not contain a valid string representation
        /// of a proxy.</exception>
        public static ExceptionOperationsPrx Parse(string s, IceRpc.IInvoker? invoker = null, IceRpc.IProxyFormat? format = null) =>
            new((format ?? IceRpc.UriProxyFormat.Instance).Parse(s, invoker));

        /// <summary>Creates a new <see cref="ExceptionOperationsPrx"/> from a string and invoker.</summary>
        /// <param name="s">The proxy string representation.</param>
        /// <param name="invoker">The invoker of the new proxy.</param>
        /// <param name="format">The proxy format to use for this parsing. Use <c>null</c> to select the default URI format.
        /// </param>
        /// <param name="prx">The new proxy.</param>
        /// <returns><c>true</c> if the s parameter was parsed successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(string s, IceRpc.IInvoker? invoker, IceRpc.IProxyFormat? format, out ExceptionOperationsPrx prx)
        {
            if ((format ?? IceRpc.UriProxyFormat.Instance).TryParse(s, invoker, out IceRpc.Proxy? proxy))
            {
                prx = new(proxy);
                return true;
            }
            else
            {
                prx = default;
                return false;
            }
        }

        /// <summary>Constructs an instance of <see cref="ExceptionOperationsPrx"/>.</summary>
        /// <param name="proxy">The proxy to the remote service.</param>
        public ExceptionOperationsPrx(IceRpc.Proxy proxy) => Proxy = proxy;

        /// <inheritdoc/>
        public override string ToString() => Proxy.ToString();

        /// <inheritdoc/>
        public global::System.Threading.Tasks.Task<string[]> IceIdsAsync(
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default) =>
            new IceRpc.Slice.ServicePrx(Proxy).IceIdsAsync(invocation, cancel);

        /// <inheritdoc/>
        public global::System.Threading.Tasks.Task<bool> IceIsAAsync(
            string id,
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default) =>
            new IceRpc.Slice.ServicePrx(Proxy).IceIsAAsync(id, invocation, cancel);

        /// <inheritdoc/>
        public global::System.Threading.Tasks.Task IcePingAsync(
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default) =>
            new IceRpc.Slice.ServicePrx(Proxy).IcePingAsync(invocation, cancel);

        /// <inheritdoc/>
        public global::System.Threading.Tasks.Task<MyExceptionA> OpMyExceptionAAsync(
            MyExceptionA p1,
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default)
        {
            var payloadEncoding = Proxy.GetSliceEncoding();
            return Proxy.InvokeAsync(
                "opMyExceptionA",
                payloadEncoding,
                Request.OpMyExceptionA(payloadEncoding, p1),
                payloadSourceStream: null,
                Response.OpMyExceptionAAsync,
                invocation,
                cancel: cancel);
        }

        /// <inheritdoc/>
        public global::System.Threading.Tasks.Task ThrowAAsync(
            int a,
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default)
        {
            var payloadEncoding = Proxy.GetSliceEncoding();
            return Proxy.InvokeAsync(
                "throwA",
                payloadEncoding,
                Request.ThrowA(payloadEncoding, a),
                payloadSourceStream: null,
                _defaultActivator,
                invocation,
                cancel: cancel);
        }

        /// <inheritdoc/>
        public global::System.Threading.Tasks.Task ThrowAorBAsync(
            int a,
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default)
        {
            var payloadEncoding = Proxy.GetSliceEncoding();
            return Proxy.InvokeAsync(
                "throwAorB",
                payloadEncoding,
                Request.ThrowAorB(payloadEncoding, a),
                payloadSourceStream: null,
                _defaultActivator,
                invocation,
                cancel: cancel);
        }

        /// <inheritdoc/>
        public global::System.Threading.Tasks.Task ThrowRemoteExceptionAsync(
            IceRpc.Slice.Invocation? invocation = null,
            global::System.Threading.CancellationToken cancel = default)
        {
            var payloadEncoding = Proxy.GetSliceEncoding();
            return Proxy.InvokeAsync(
                "throwRemoteException",
                payloadEncoding,
                payloadEncoding.CreateEmptyPayload(hasStream: false),
                payloadSourceStream: null,
                _defaultActivator,
                invocation,
                cancel: cancel);
        }
    }

    /// <summary>Interface used to implement services for Slice interface ExceptionOperations. <seealso cref="IExceptionOperationsPrx"/>.</summary>
    [IceRpc.Slice.TypeId("::IceRpc::Tests::Slice::ExceptionOperations")]
    public partial interface IExceptionOperations
    {
        /// <summary>Provides static methods that read the arguments of requests.</summary>
        public static class Request
        {
            /// <summary>Decodes the argument of operation OpMyExceptionA.</summary>
            public static async global::System.Threading.Tasks.ValueTask<MyExceptionA> OpMyExceptionAAsync(
                IceRpc.IncomingRequest request,
                global::System.Threading.CancellationToken cancel) =>
                await request.ToArgsAsync(
                    _defaultActivator,
                    (ref SliceDecoder decoder) => new MyExceptionA(ref decoder),
                    hasStream: false,
                    cancel).ConfigureAwait(false);

            /// <summary>Decodes the argument of operation ThrowA.</summary>
            public static async global::System.Threading.Tasks.ValueTask<int> ThrowAAsync(
                IceRpc.IncomingRequest request,
                global::System.Threading.CancellationToken cancel) =>
                await request.ToArgsAsync(
                    _defaultActivator,
                    (ref SliceDecoder decoder) => decoder.DecodeInt(),
                    hasStream: false,
                    cancel).ConfigureAwait(false);

            /// <summary>Decodes the argument of operation ThrowAorB.</summary>
            public static async global::System.Threading.Tasks.ValueTask<int> ThrowAorBAsync(
                IceRpc.IncomingRequest request,
                global::System.Threading.CancellationToken cancel) =>
                await request.ToArgsAsync(
                    _defaultActivator,
                    (ref SliceDecoder decoder) => decoder.DecodeInt(),
                    hasStream: false,
                    cancel).ConfigureAwait(false);
        }

        /// <summary>Provides static methods that write the return values of responses.</summary>
        public static class Response
        {
            /// <summary>Creates a response payload for operation OpMyExceptionA.</summary>
            /// <returns>A new response payload.</returns>
            /// <param name="encoding">The encoding of the payload</param>
            /// <param name="returnValue">The operation return value</param>
            public static global::System.IO.Pipelines.PipeReader OpMyExceptionA(
                SliceEncoding encoding,
                MyExceptionA returnValue)
            {
                var pipe_ = new global::System.IO.Pipelines.Pipe(); // TODO: pipe options

                var encoder_ = new SliceEncoder(pipe_.Writer, encoding, default);
                Span<byte> sizePlaceholder_ = encoder_.GetPlaceholderSpan(4);
                int startPos_ = encoder_.EncodedByteCount;
                encoder_.EncodeException(returnValue);
                encoding.EncodeFixedLengthSize(encoder_.EncodedByteCount - startPos_, sizePlaceholder_);

                pipe_.Writer.Complete();  // flush to reader and sets Is[Writer]Completed to true.
                return pipe_.Reader;
            }
        }

        private static readonly IActivator _defaultActivator =
            SliceDecoder.GetActivator(typeof(IExceptionOperations).Assembly);

        /// <param name="dispatch">The dispatch properties</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        public global::System.Threading.Tasks.ValueTask<MyExceptionA> OpMyExceptionAAsync(
            MyExceptionA p1,
            IceRpc.Slice.Dispatch dispatch,
            global::System.Threading.CancellationToken cancel = default);

        /// <param name="dispatch">The dispatch properties</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        public global::System.Threading.Tasks.ValueTask ThrowAAsync(
            int a,
            IceRpc.Slice.Dispatch dispatch,
            global::System.Threading.CancellationToken cancel = default);

        /// <param name="dispatch">The dispatch properties</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        public global::System.Threading.Tasks.ValueTask ThrowAorBAsync(
            int a,
            IceRpc.Slice.Dispatch dispatch,
            global::System.Threading.CancellationToken cancel = default);

        /// <param name="dispatch">The dispatch properties</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        public global::System.Threading.Tasks.ValueTask ThrowRemoteExceptionAsync(
            IceRpc.Slice.Dispatch dispatch,
            global::System.Threading.CancellationToken cancel = default);

        [IceRpc.Slice.Operation("opMyExceptionA")]
        protected static async global::System.Threading.Tasks.ValueTask<(SliceEncoding, global::System.IO.Pipelines.PipeReader, global::System.IO.Pipelines.PipeReader?)> SliceDOpMyExceptionAAsync(
            IExceptionOperations target,
            IceRpc.IncomingRequest request,
            global::System.Threading.CancellationToken cancel)
        {
            request.CheckNonIdempotent();
            var sliceP_p1 = await Request.OpMyExceptionAAsync(request, cancel).ConfigureAwait(false);
            var returnValue = await target.OpMyExceptionAAsync(sliceP_p1, new IceRpc.Slice.Dispatch(request), cancel).ConfigureAwait(false);
            var payloadEncoding = request.GetSliceEncoding();
            return (payloadEncoding, Response.OpMyExceptionA(payloadEncoding, returnValue), null);
        }

        [IceRpc.Slice.Operation("throwA")]
        protected static async global::System.Threading.Tasks.ValueTask<(SliceEncoding, global::System.IO.Pipelines.PipeReader, global::System.IO.Pipelines.PipeReader?)> SliceDThrowAAsync(
            IExceptionOperations target,
            IceRpc.IncomingRequest request,
            global::System.Threading.CancellationToken cancel)
        {
            request.CheckNonIdempotent();
            var sliceP_a = await Request.ThrowAAsync(request, cancel).ConfigureAwait(false);
            await target.ThrowAAsync(sliceP_a, new IceRpc.Slice.Dispatch(request), cancel).ConfigureAwait(false);
            var payloadEncoding = request.GetSliceEncoding();
            return (payloadEncoding, payloadEncoding.CreateEmptyPayload(hasStream: false), null);
        }

        [IceRpc.Slice.Operation("throwAorB")]
        protected static async global::System.Threading.Tasks.ValueTask<(SliceEncoding, global::System.IO.Pipelines.PipeReader, global::System.IO.Pipelines.PipeReader?)> SliceDThrowAorBAsync(
            IExceptionOperations target,
            IceRpc.IncomingRequest request,
            global::System.Threading.CancellationToken cancel)
        {
            request.CheckNonIdempotent();
            var sliceP_a = await Request.ThrowAorBAsync(request, cancel).ConfigureAwait(false);
            await target.ThrowAorBAsync(sliceP_a, new IceRpc.Slice.Dispatch(request), cancel).ConfigureAwait(false);
            var payloadEncoding = request.GetSliceEncoding();
            return (payloadEncoding, payloadEncoding.CreateEmptyPayload(hasStream: false), null);
        }

        [IceRpc.Slice.Operation("throwRemoteException")]
        protected static async global::System.Threading.Tasks.ValueTask<(SliceEncoding, global::System.IO.Pipelines.PipeReader, global::System.IO.Pipelines.PipeReader?)> SliceDThrowRemoteExceptionAsync(
            IExceptionOperations target,
            IceRpc.IncomingRequest request,
            global::System.Threading.CancellationToken cancel)
        {
            request.CheckNonIdempotent();
            await request.CheckEmptyArgsAsync(hasStream: false, cancel).ConfigureAwait(false);
            await target.ThrowRemoteExceptionAsync(new IceRpc.Slice.Dispatch(request), cancel).ConfigureAwait(false);
            var payloadEncoding = request.GetSliceEncoding();
            return (payloadEncoding, payloadEncoding.CreateEmptyPayload(hasStream: false), null);
        }
    }

    [IceRpc.Slice.TypeId("::IceRpc::Tests::Slice::MyExceptionA")]
    public partial class MyExceptionA : IceRpc.Slice.RemoteException
    {
        public int M1;

        public static readonly string SliceTypeId = typeof(MyExceptionA).GetSliceTypeId()!;

        /// <summary>Constructs a new instance of <see cref="MyExceptionA"/>.</summary>
        /// <param name="retryPolicy">The retry policy for the exception.</param>
        public MyExceptionA(
            int m1,
            IceRpc.RetryPolicy? retryPolicy = null)
            : base(retryPolicy)
        {
            this.M1 = m1;
        }

        /// <summary>Constructs a new instance of <see cref="MyExceptionA"/>.</summary>
        /// <param name="message">Message that describes the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception.</param>
        /// <param name="retryPolicy">The retry policy for the exception.</param>
        public MyExceptionA(
            string? message,
            int m1,
            global::System.Exception? innerException = null,
            IceRpc.RetryPolicy? retryPolicy = null)
            : base(message, innerException, retryPolicy)
        {
            this.M1 = m1;
        }

        /// <param name="retryPolicy">The retry policy for the exception</param>
        public MyExceptionA(IceRpc.RetryPolicy? retryPolicy = null)
            : base(retryPolicy)
        {
        }

        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public MyExceptionA(ref SliceDecoder decoder)
            : base(ref decoder)
        {
            if (decoder.Encoding == IceRpc.Encoding.Slice11)
            {

            }
            else
            {
                this.M1 = decoder.DecodeInt();
            }
        }

        protected override void DecodeCore(ref SliceDecoder decoder)
        {
            decoder.StartSlice();
            this.M1 = decoder.DecodeInt();
            decoder.EndSlice();
        }

        protected override void EncodeCore(ref SliceEncoder encoder)
        {
            if (encoder.Encoding == IceRpc.Encoding.Slice11)
            {
                encoder.StartSlice(SliceTypeId);
                encoder.EncodeInt(this.M1);
                encoder.EndSlice(lastSlice: true);
            }
            else
            {
                encoder.EncodeString(SliceTypeId);
                encoder.EncodeString(Message);
                Origin.Encode(ref encoder);
                encoder.EncodeInt(this.M1);
                encoder.EncodeVarInt(Slice20Definitions.TagEndMarker);
            }
        }
    }

    [IceRpc.Slice.TypeId("::IceRpc::Tests::Slice::MyExceptionB")]
    public partial class MyExceptionB : IceRpc.Slice.RemoteException
    {
        public int M1;

        public static readonly string SliceTypeId = typeof(MyExceptionB).GetSliceTypeId()!;

        /// <summary>Constructs a new instance of <see cref="MyExceptionB"/>.</summary>
        /// <param name="retryPolicy">The retry policy for the exception.</param>
        public MyExceptionB(
            int m1,
            IceRpc.RetryPolicy? retryPolicy = null)
            : base(retryPolicy)
        {
            this.M1 = m1;
        }

        /// <summary>Constructs a new instance of <see cref="MyExceptionB"/>.</summary>
        /// <param name="message">Message that describes the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception.</param>
        /// <param name="retryPolicy">The retry policy for the exception.</param>
        public MyExceptionB(
            string? message,
            int m1,
            global::System.Exception? innerException = null,
            IceRpc.RetryPolicy? retryPolicy = null)
            : base(message, innerException, retryPolicy)
        {
            this.M1 = m1;
        }

        /// <param name="retryPolicy">The retry policy for the exception</param>
        public MyExceptionB(IceRpc.RetryPolicy? retryPolicy = null)
            : base(retryPolicy)
        {
        }

        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public MyExceptionB(ref SliceDecoder decoder)
            : base(ref decoder)
        {
            if (decoder.Encoding == IceRpc.Encoding.Slice11)
            {

            }
            else
            {
                this.M1 = decoder.DecodeInt();
            }
        }

        protected override void DecodeCore(ref SliceDecoder decoder)
        {
            decoder.StartSlice();
            this.M1 = decoder.DecodeInt();
            decoder.EndSlice();
        }

        protected override void EncodeCore(ref SliceEncoder encoder)
        {
            if (encoder.Encoding == IceRpc.Encoding.Slice11)
            {
                encoder.StartSlice(SliceTypeId);
                encoder.EncodeInt(this.M1);
                encoder.EndSlice(lastSlice: true);
            }
            else
            {
                encoder.EncodeString(SliceTypeId);
                encoder.EncodeString(Message);
                Origin.Encode(ref encoder);
                encoder.EncodeInt(this.M1);
                encoder.EncodeVarInt(Slice20Definitions.TagEndMarker);
            }
        }
    }
}